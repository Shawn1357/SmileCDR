#
# Property Names below are composed of up to four parts separated by 
# periods ('.'), the first four of which may be in any order (and are expected
# to be in lower-case):
#   1. Property Name      (Required)
#   2. Application Name   (Optional)
#   3. Environment Name   (Optional)
#   4. Instance Name      (Optional)
#   4. Index Number       (Optional - must be a positive integer)
#
# 1. Property Name
# ----------------
# The property name is the only required part of an entry in this properties
# file and it is the key by the application will search for values relating
# to that property.  The remaining three components are adornments that are
# optionally added to provide additional specificity across multiple
# applications and/or environments if that is required.
#
# For example: if the properties file contains:
#     sample-property-a = Some Value A
#     sample-property-b = Some Value B
#
# The application would request the values associated with 'sample-property-a'.
#
#
# 2. Application Name
# -------------------
# This is an optional component which identifies properties that are specific
# to a particular application.  This is a convenience if the same proeprty key
# might be used across multiple applications and have different values 
# depending on the application.
#
# The application name itself can be supplied through a command line parameter
#    -c <app-name>   or  --cfgName <app-name>
#
# but would default to a lower-case copy of the simple class name containing
# the Main entry point.  As an example, if you had the following java class
# file:
#
#         package  ca.ontariohealth.sampleapp;
#         ...
#         public class ASampleApp
#         {
#         public static void Main( String[] args )
#             {
#             ...
#             }
#         }
#
# In this case:
#     - The full class name is: ca.ontarionhealth.sampleApp.ASampleApp
#     - The simple class name is: ASampleApp
#     - The app name as it should appear in the properties: asampleapp
#
# As an example, if you have the following properties:
#
#      app-name-1.interesting.property = A Value for App 1
#      app-name-2.interesting.property = A Value for App 2
#      app-name-3.interesting.property = A Value for App 3
#
# And if an application named 'app-name-2' is running and requests the value
# for property 'interesting.property', it will be returned: 'A Value for App 2'
# and the values specific to applications: 'app-name-1' and 'app-name-3' will
# be ignored.
#
#
# 3. Environment Name
# -------------------
# This optional component of a property entry can be used to identify property
# settings for a property name that are environment specific.  For instance,
# you may havce a setting for a property that applies in a development
# environment but have a different value for the same property in a test,
# stage or production environment.
#
# The environment name can only be supplied through the command line parameter
#    -e <env-name>   or   --envName <env-name>
#
# If the environment name is not provided, it is not used and any environment
# specific properties listed in this file will be ignored.
#
# For example, if your app is running in the 'tst' environment and you have
# the following properties listed:
#
#        dev.server.ip.address = 10.1.10.20
#        tst.server.ip-address = 10.2.20.30
#        stg.server.ip.address = 10.3.30.40
#        prd.server.ip-address = 10.4.40.50
#
# And the application requests the value for the property: 'server.ip.address',
# the value '10.2.20.30' will be returned and the other values will be
# ignored.
#
#
# 4. Application Instance Name
# ----------------------------
#
# If there are two instances of an application running at the same time to
# similar or slightly different jobs, each of these instances and can be given
# a name and thereby be given different configuration settings.
#
# The application instance name can only be supplied through the command line
# parameter:
#    -i <inst-name>   or   --instName <inst-name>
#
# If the instance name is not provided, it is not used and any instance
# specific properties listed in this file will be ignored.
#
# For example, if your dlqwatcher app is running in two instances: one to watch
# the KAFKA.DLQ topic, and a second to watch the KAFKA.PARKED topic, you may
# choose to give the first the instance name 'DLQ' and the second the instance
# name 'PARKED'.  The a look up for the Kafka Topic Name to watch could be
# requested with:
#
#        dlq.topic.name    = KAFKA.DLQ
#        parked.topic.name = KAFKA.PARKED
#
#
# 5. Index Number - Arrays of Values:
# -----------------------------------
# Properties may have any number of values associated with them and make for a
# group of values associated with a single property. To indicate multiple
# values for a single property, an integral index must be appended to the
# end of the property name. For instance:
#
#     property-name.1 = Value 1
#     property-name.2 = Value 2
#     property-name.3 = Value 3
#
#     another-prop    = Value 4
#
# When the application requests the values for 'property-name', it will be
# returned the list of values: ['Value 1', 'Value 2', 'Value 3'].  This list
# may be of any length.
#
# Technically, even when there is no integer suffix to the property, the
# application will still receive a list of values, but that list will
# have length 1.  So requesting 'another-prop' will result in a list of a
# single value: ['Value 4'].
#
#
# Property Lookup Search Mechanism
# --------------------------------
# When an application searches for a property, it searches by the Property Name
# only.  The application does not need to consider the application name or
# the environment name that is associated with.
#
# The tuple: Property Name, Environment Name, Instance Name and Property Name 
# may appear in any order inc ombination with the required Property Name
# component.  Each of the Property, Environment and Instance Names are
# individually optional and so may be supplied or not as part of a property
# specification.
#
# The search order looks for entries in this properties file in the following
# order, moving from most specific to most widely applied property value.
# The search mechanism stops are returns all values with the located
# combination of Application, Environment, Instance and Property Names.
#
# For each combination, the application asks itself:
#    - Are all identified components available to the application (only the 
#      Property Name is Required), and
#    - Are there one or more properties which match the specified combination
#      of components (remember, any combination my have an optional integer
#      suffix which indicates an array of values for that combination).
#
# If the answer is no to either of those questions, the current combination
# is skipped and we move on to the next combination.  This process continues
# until a match is found or we run out of combinations to try.
#
#           Specific to a Particular Application, Instance and Environment
#           --------------------------------------------------------------
#
#           There are 24 possible permutations of the four elements when all
#           supplied in the configuration file:
#       1.  {App Name}.{Env Name}.{Instance}.{Property}
#       2.  {App Name}.{Env Name}.{Property}.{Instance}
#           ...
#      23.  {Property}.{Instance}.{App Name}.{Env Name}
#      24.  {Property}.{Instance}.{Env Name}.{App Name}
#
#           Combinations missing only Application
#           -------------------------------------
#      25.  {Instance}.{App Name}.{Property}
#      26.  {Instance}.{Property}.{App Name}
#           ...
#
#           Applicable to either All Applications
#           -------------------------------------
#       9.  {Env Name}.{Property}
#      10.  {Property}.{Env Name}
#
#           Applicable to all Applications and Environments
#           -----------------------------------------------
#      11.  {Property}
#
#
# For example, suppose you have the following set of properties:
#
#      property.nm                 = Generic Value
#      property.nm.app-nm-1        = Generic across all envs for app 'app-nm-1'
#      property.nm.app-nm-2        = Generic across all envs for app 'app-nm-2'
#      property.nm.dev             = Generic across all apps for env 'dev'
#      property.nm.tst.1           = Generic across all apps for env 'tst' - Val 1
#      property.nm.tst.2           = Generic across all apps for env 'tst' - Val 2
#      property.nm.prd             = Generic across all apps for env 'prd'
#      property.nm.dev.app-nm-1    = Specific to app 'app-nm-1' in env 'dev'
#      property.nm.app-nm-2.dev    = Specific to app 'app-nm-2' in env 'dev'
#      app-nm-2.tst.property.nm.1  = Specific to app 'app-nm-2' in env 'tst' - Val 1
#      app-nm-2.tst.property.nm.2  = Specific to app 'app-nm-2' in env 'tst' - Val 2
#
#
#   The an application looking up 'property.nm' having:
#      Name: app-nm-1,  Env: dev  would get: ["Specific to app 'app-nm-1' in env 'dev'"]
#      Name: app-nm-3,  Env: tst  would get: ["Generic across all apps for env 'tst' - Val 1",
#                                             "Generic across all apps for env 'tst' - Val 2"]
#      Name: app-nm-4,  Env: prd  would get: ["Generic Value"]
#

dlqwatcher.application.name        = Kafka Dead-Letter-Queue Watcher
dlqwatcher.application.desc        = Issues alerts when the SmileCDR Dead Letter Queue receives entries.
dlqwatcher.version.num             = 0.0.2
dlqwatcher.build.date              = 2022-06-07

dlqwatchercontrol.application.name = DLQ Watcher Control App
dlqwatchercontrol.application.desc = App to control the execution of the DLQ Watcher
dlqwatchercontrol.version.num      = 0.0.2
dlqwatchercontrol.build.date       = 2022-06-07

copyright.holder                   = Accenture, Inc.
copyright.year.start               = 2022
copyright.year.end                 =

timestamp.format                   = yyyy-MM-dd HH:mm:ss


#
# When the DLQ Watcher receives a START command (which launches the underlying
# threads), the following entries control whether or not the relevant threads 
# are started on not.  There is one entry for each of the underlying helper
# threads.
#
#

dlqwatcher.start.cmd.include.dlqpoll.thread        = true
dlqwatcher.start.cmd.include.parkpoll.thread       = true
dlqwatcher.start.cmd.include.parkdqlentries.thread = true

lcl-dev.dlqwatcher.start.cmd.include.dlqpoll.thread        = true
lcl-dev.dlqwatcher.start.cmd.include.parkpoll.thread       = true
lcl-dev.dlqwatcher.start.cmd.include.parkdlqentries.thread = true

dlqwatcher.stop.cmd.max.wait.for.thread.millis         = 10000
lcl-dev.dlqwatcher.stop.cmd.max.wait.for.thread.millis = 5000



# Comma separated list of bootstrap servers
#dev.bootstrap.servers  = smilecdr:9092,localhost:9092
lcl-dev.bootstrap.servers      = smilecdr:9092
cwm-dev.bootstrap.servers      = 10.116.96.134:9092

kafka.default.rentention.hours = 168

control.group.id               = SmileCDR.Control.Watcher
dlqwatcher.dlq.group.id        = SmileCDR.DLQ.Watcher
dlqwatcher.dlq.lister.group.id = SmileCDR.DLQ.Lister
dlqresend.resend.group.id      = SmileCDR.DLQ.Resend
consumer.poll.interval         = 500

kafka.park.watcher.group.id       = SmileCDR.PARK.Watcher
kafka.park.lister.group.id        = SmileCDR.PARK.Lister
kafka.dlq.topic.name              = KAFKA.DLQ
dlq.entry.retention.hours         = 168
lcl-dev.dlq.park.after.hours      = 2
lcl-dev.dlq.entry.retention.hours = 48

kafka.parked.topic.name              = KAFKA.PARK
parked.entry.retention.hours         = Forever
lcl-dev.parked.entry.retention.hours = 1

#
# The interval to check for the Dead Letter Queue for entries that may
# expire (in minutes).
#
dlq.frequency.mins.to.park.entries         = 120
lcl-dev.dlq.frequency.mins.to.park.entries = 2


# The cwm-dlq instance of the DLQWatcher uses this parser (which extends
# ca.ontariohealth.smilecdr.support.kafka.KafkaTopicRecordParser) to read and
# make sense of records coming off of the SmileCDR Dead Letter Queue.
dlqwatcher.cwm-dlq.dlq.parser.class.name = ca.ontariohealth.smilecdr.support.commands.response.CWMDLQRecordEntry

# Cause the DLQWatcher to automatically stop after this many milliseconds,
# Indicates to immediately stop.
# Comment out this property to run indefinitely (until the QUIT command
# is explicitly sent via the DLQWatcherControl App).
#dlqwatcher.lcl-dev.quit.after.millis      = 360000

dlqwatcher.lcl-dev.email.server.smtp      = bdenim.ca
dlqwatcher.lcl-dev.email.server.smtp.port = 25
dlqwatcher.lcl-dev.email.credentials.file = emailcredentials.cred

dlqwatcher.lcl-dev.email.newdlq.template.nm      = template01
dlqwatcher.lcl-dev.email.dlqlist.template.nm     = template02
dlqwatcher.lcl-dev.email.newpark.template.nm     = template03
dlqwatcher.lcl-dev.email.parklist.template.nm    = template04


dlqwatcher.lcl-dev.email.from.template01            = testaccount@bdenim.ca
# Multiple To, CC, and BCC email addresses are OK if separated by commas
#dlqwatcher.lcl-dev.email.to.template01              = shawnabrant@gmail.com,gila.kats@ontariohealth.ca,sherman.quan@accenture.com
dlqwatcher.lcl-dev.email.to.template01              = shawnabrant@gmail.com
dlqwatcher.lcl-dev.email.cc.template01              = 
dlqwatcher.lcl-dev.email.bcc.template01             =
dlqwatcher.email.subject.template01                 = New CWM Dead Letter Queue Entries
dlqwatcher.email.body.incl.hashtag.lines.template01 = false
dlqwatcher.email.body.file.nm.template01            = emailTemplate01.txt

dlqwatcher.lcl-dev.email.from.template02            = testaccount@bdenim.ca
# Multiple To, CC, and BCC email addresses are OK if separated by commas
#dlqwatcher.lcl-dev.email.to.template02              = shawnabrant@gmail.com,gila.kats@ontariohealth.ca,sherman.quan@accenture.com
dlqwatcher.lcl-dev.email.to.template02              = shawnabrant@gmail.com
dlqwatcher.lcl-dev.email.cc.template02              = 
dlqwatcher.lcl-dev.email.bcc.template02             =
dlqwatcher.email.subject.template02                 = Existing CWM Dead Letter Queue Entries
dlqwatcher.email.body.incl.hashtag.lines.template02 = false
dlqwatcher.email.body.file.nm.template02            = emailTemplate02.txt

dlqwatcher.lcl-dev.email.from.template03            = testaccount@bdenim.ca
# Multiple To, CC, and BCC email addresses are OK if separated by commas
#dlqwatcher.lcl-dev.email.to.template03              = shawnabrant@gmail.com,gila.kats@ontariohealth.ca,sherman.quan@accenture.com
dlqwatcher.lcl-dev.email.to.template03              = shawnabrant@gmail.com
dlqwatcher.lcl-dev.email.cc.template03              = 
dlqwatcher.lcl-dev.email.bcc.template03             =
dlqwatcher.email.subject.template03                 = New CWM Parking Lot Queue Entries
dlqwatcher.email.body.incl.hashtag.lines.template03 = false
dlqwatcher.email.body.file.nm.template03            = emailTemplate03.txt

dlqwatcher.lcl-dev.email.from.template04            = testaccount@bdenim.ca
# Multiple To, CC, and BCC email addresses are OK if separated by commas
#dlqwatcher.lcl-dev.email.to.template04              = shawnabrant@gmail.com,gila.kats@ontariohealth.ca,sherman.quan@accenture.com
dlqwatcher.lcl-dev.email.to.template04              = shawnabrant@gmail.com
dlqwatcher.lcl-dev.email.cc.template04              = 
dlqwatcher.lcl-dev.email.bcc.template04             =
dlqwatcher.email.subject.template04                 = Existing CWM Parking Lot Queue Entries
dlqwatcher.email.body.incl.hashtag.lines.template04 = false
dlqwatcher.email.body.file.nm.template04            = emailTemplate04.txt



# These two properties should identify the same topic:
# The first identifies the topic to which the control app sends commands.
# The second identifies the topic the watcher app polls to receive commands.

dlqwatchercontrol.topic.name.command    = DLQWatcherControlTopic
dlqwatcher.topic.name.command           = DLQWatcherControlTopic

dlqwatchercontrol.topic.name.response   = DLQWatcherResponseTopic
dlqwatcher.topic.name.response          = DLQWatcherResponseTopic

# The amount of time to wait before starting to listen for a response from
# the DLQWatcher application.  Applies only to the DLQ Watcher Control app.
# If not specified, the default is 0 (no wait).
dlqwatchercontrol.pause.before.response = 0


# In a synchronous exchange of data, such as DLQWatcher Control to DLQ Watcher,
# this is the maximum time to wait for a response to appear.  Internal
# hard coded default is 30000
response.wait.millis = 15000
dlqwatchercontrol.response.wait.millis = 20000


dlqresend.lcl-dev.retrigger.url  = http://smilecdr:8000/Subscription/{{SubscriptionID}}/$trigger-subscription 
dlqresend.retrigger.body         = {"resourceType": "Parameters", "parameter": [{"name": "resourceId", "valueUri": "{{ResourceType}}/{{ResourceID}}"}]}



# Severity must be one of: DEBUG, INFO, WARN, ERROR, FATAL
processing.severity.dlqw-0000 = INFO
processing.format.dlqw-0000   = Success

# First argument is Thread Name: DLQ Poller, etc.
processing.severity.dlqw-0001 = INFO
processing.format.dlqw-0001   = %s Thread is already alive: nothing to do.

# First argument is Thread Name: DLQ Poller, etc.
processing.severity.dlqw-0002 = ERROR
processing.format.dlqw-0002   = "%s Thread did not start."

# First argument is Thread Name: DLQ Poller, etc.
processing.severity.dlqw-0003 = INFO
processing.format.dlqw-0003   = %s Thread is running.

# First argument is Thread Name: DLQ Poller, etc.
processing.severity.dlqw-0004 = INFO
processing.format.dlqw-0004   = %s Thread is not running: nothing to do.

# First argument is Thread Name: DLQ Poller, etc.
processing.severity.dlqw-0005 = WARN
processing.format.dlqw-0005   = %s Thread is running but Configuration indicates it should not be.

# First argument is ThreadName: DLQ Poller, etc.
# Second argument is Max Wait in Milliseconds.
processing.severity.dlqw-0006 = WARN
processing.format.dlqw-0006   = %s Thread is still alive after %s milliseconds. Killing it.
